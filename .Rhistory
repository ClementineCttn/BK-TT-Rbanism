map_city_streets2(survey_google[, 4][[sl]])
x = "Bucharest Romania"
## get municipal boundary from osmdata
bb <- osmdata::getbb(place_name = x,
format_out = 'sf_polygon',
silent = FALSE)
## get data from osmextract
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
quiet = TRUE)
nrow(osm_lines)
x
## get data from osmextract
osm_lines = oe_get(bb,
stringsAsFactors = FALSE,
quiet = TRUE)
nrow(osm_lines)
## get data from osmextract
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
quiet = FALSE)
x <- "bucharest, RO"
## get municipal boundary from osmdata
bb <- osmdata::getbb(place_name = x,
format_out = 'sf_polygon',
silent = FALSE)
## get data from osmextract
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
quiet = FALSE)
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
force_download = TRUE,
quiet = FALSE)
map_city_streets2 <- function(x) {
## get municipal boundary from osmdata
bb <- osmdata::getbb(place_name = x,
format_out = 'sf_polygon',
silent = FALSE)
## get data from osmextract
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
# force_download = TRUE,
quiet = FALSE)
nrow(osm_lines)
## get highway types of interest
ht <- c(
"motorway",
"motorway_link",
"primary",
"primary_link",
"secondary",
"tertiary",
"unclassified"
)
osm_major_roads <- osm_lines[osm_lines$highway %in% ht, ] %>%
sf::st_intersection(bb)
## plot data
plot(bb)
plot(
osm_major_roads["highway"]$geometry,
key.pos = 1,
add = T,
col = "red",
lwd = 0.7
)
}
t
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets2(survey_google[, 4][[sl]])
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(tidyverse)  # collection of packages for data manipulation, visualisation, etc.
library(googlesheets4)  # access data from Google sheets
library(sf)  # working with spatial data
library(osmdata)  # access OpenStreetMap data via the Overpass API
library(osmextract)  # retrieve bulk OpenStreetMap data
library(ggmap)
library(kableExtra)  # create and style HTML tables
# lists the files with "survey-" in their name in the same folder as this document
files <- list.files(pattern="^survey-")
files
# creates an empty table
survey <- tibble()
n <- length(files)
# the 'for-loop':
for (i in 1:n){
f <- read.csv2(files[i], header=F)
if(i == 1){
survey <- f
} else {
survey <- cbind(survey, f[,2])
}
}
transpose <- as.data.frame(t(survey))
colnames(transpose) <- c("Name", "ArrivalYearTU", "CityBefore", "InterestR", "Experience")
survey_together <- transpose[-1,]
rownames(survey_together) <- 1:n
survey_together$ArrivalYearTU <- as.numeric(survey_together$ArrivalYearTU)
survey_together$InterestR <- as.numeric(survey_together$InterestR)
# as with spreadsheets, we can create new variables
survey_together$SeniorityAtTUD <- 2021 - survey_together$ArrivalYearTU
survey_together
# Read survey data from a Google sheet that stores the survey responses
# Note that getting data via `googlesheets4` requires a Google account
# unless `gs4_deauth()` is used. Here we choose to deauthorise so that
# the workshop participants can easily access the data.
gs4_deauth()
survey_google <- read_sheet("https://docs.google.com/spreadsheets/d/1_eErh6dy7uMiEewDc4OW_R3sl0qah2-1kYj3JW9H5tA/edit?resourcekey#gid=800252241")
# clean survey data
colnames(survey_google) <- c("timestamp", "name", "year_start_tud", "place", "interest_r", "progr_exp")
survey_google <- survey_google %>%
mutate(progr_exp = ifelse(progr_exp == "Yes", TRUE, FALSE)) %>%
filter(!grepl("Test", name))
# print cleaned survey data
survey_google
survey_google %>%
kbl() %>%
kable_styling(bootstrap_options = c("striped", "hover"))
library(ggplot2)
q <- ggplot(survey_together, aes(x=SeniorityAtTUD, y=InterestR))
q + geom_point()
fit <- lm(InterestR ~ SeniorityAtTUD, data = survey_together)
ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "red") +
labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 2),
"Intercept =",signif(fit$coef[[1]],2 ),
" Slope =",signif(fit$coef[[2]], 2),
" P =",signif(summary(fit)$coef[2,4], 2)))
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
for (i in 1:nrow(places)){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
#map places on interactive map
leaflet(bbx) %>% addProviderTiles("CartoDB.Positron") %>%
addPolygons()
sl <- nrow(survey_google)
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(survey_google[, 4][[sl]])
survey_google
sl
nrow(survey_google)
survey_google[, 4]
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(survey_google[, 4][sl, ])
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(survey_google[, 4][sl])
survey_google[, 4]
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(pull(survey_google[, 4])[sl])
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
map_city_streets2 <- function(x) {
## get municipal boundary from osmdata
bb <- osmdata::getbb(place_name = x,
format_out = 'sf_polygon',
silent = FALSE)
## get data from osmextract
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
# force_download = TRUE,
quiet = FALSE)
nrow(osm_lines)
## get highway types of interest
ht <- c(
"motorway",
"motorway_link",
"primary",
"primary_link",
"secondary",
"tertiary",
"unclassified"
)
osm_major_roads <- osm_lines[osm_lines$highway %in% ht, ] %>%
sf::st_intersection(bb)
## plot data
plot(bb)
plot(
osm_major_roads["highway"]$geometry,
key.pos = 1,
add = T,
col = "red",
lwd = 0.7
)
}
osmextract::oe_get("Iran")
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
library(tidyverse)  # collection of packages for data manipulation, visualisation, etc.
library(googlesheets4)  # access data from Google sheets
library(sf)  # working with spatial data
library(osmdata)  # access OpenStreetMap data via the Overpass API
library(osmextract)  # retrieve bulk OpenStreetMap data
library(ggmap)
library(kableExtra)  # create and style HTML tables
# lists the files with "survey-" in their name in the same folder as this document
files <- list.files(pattern="^survey-")
files
# creates an empty table
survey <- tibble()
n <- length(files)
# the 'for-loop':
for (i in 1:n){
f <- read.csv2(files[i], header=F)
if(i == 1){
survey <- f
} else {
survey <- cbind(survey, f[,2])
}
}
transpose <- as.data.frame(t(survey))
colnames(transpose) <- c("Name", "ArrivalYearTU", "CityBefore", "InterestR", "Experience")
survey_together <- transpose[-1,]
rownames(survey_together) <- 1:n
survey_together$ArrivalYearTU <- as.numeric(survey_together$ArrivalYearTU)
survey_together$InterestR <- as.numeric(survey_together$InterestR)
# as with spreadsheets, we can create new variables
survey_together$SeniorityAtTUD <- 2021 - survey_together$ArrivalYearTU
survey_together
# Read survey data from a Google sheet that stores the survey responses
# Note that getting data via `googlesheets4` requires a Google account
# unless `gs4_deauth()` is used. Here we choose to deauthorise so that
# the workshop participants can easily access the data.
gs4_deauth()
survey_google <- read_sheet("https://docs.google.com/spreadsheets/d/1_eErh6dy7uMiEewDc4OW_R3sl0qah2-1kYj3JW9H5tA/edit?resourcekey#gid=800252241")
# clean survey data
colnames(survey_google) <- c("timestamp", "name", "year_start_tud", "place", "interest_r", "progr_exp")
survey_google <- survey_google %>%
mutate(progr_exp = ifelse(progr_exp == "Yes", TRUE, FALSE)) %>%
filter(!grepl("Test", name))
# print cleaned survey data
survey_google
survey_google %>%
kbl() %>%
kable_styling(bootstrap_options = c("striped", "hover"))
library(ggplot2)
q <- ggplot(survey_together, aes(x=SeniorityAtTUD, y=InterestR))
q + geom_point()
fit <- lm(InterestR ~ SeniorityAtTUD, data = survey_together)
ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "red") +
labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 2),
"Intercept =",signif(fit$coef[[1]],2 ),
" Slope =",signif(fit$coef[[2]], 2),
" P =",signif(summary(fit)$coef[2,4], 2)))
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
for (i in 1:nrow(places)){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
bb
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
?getbb
assign
bbx
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
for (i in 4:nrow(places)){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
7:nrow(places)
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
for (i in c(1,2,4,5,7:nrow(places)){
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
for (i in c(1,2,4,5,7:nrow(places))){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
#map places on interactive map
leaflet(bbx) %>% addProviderTiles("CartoDB.Positron") %>%
addPolygons()
## create a function to extract the streets of a city x
map_city_streets <- function(x) {
osm_lines = oe_get(x, stringsAsFactors = FALSE, quiet = TRUE)
nrow(osm_lines)
# get highway types of interest
# ht <- c("primary", "secondary", "tertiary", "unclassified")
ht <- c("motorway", "motorway_link", "primary", "primary_link")
bb <- osmdata::getbb(place_name = x,
format_out = 'sf_polygon',
silent = FALSE)
osm_major_roads_place <- osm_lines[osm_lines$highway %in% ht,] %>%
sf::st_intersection(bb)
plot(bb[[1]])
plot(osm_major_roads_place$geometry, add = T, col = "red")
}
## let's map it for Rotterdam
map_city_streets("Rotterdam, NL")
sl <- nrow(survey_google)
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(pull(survey_google[, 4])[sl])
osmextract::oe_get("cologne")
sl <- nrow(survey_google)
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(pull(survey_google[, 4])[sl])
library(sf)
library(osmextract)
library(osmdata)
# get places from csv survey
# places <- survey[, 2]
# get places from google survey
# places_google <- pull(survey_google[, 4])
map_city_streets2 <- function(x) {
## get municipal boundary from osmdata
bb <- osmdata::getbb(place_name = x,
format_out = 'sf_polygon',
silent = FALSE)
## get data from osmextract
osm_lines = oe_get(x,
stringsAsFactors = FALSE,
# force_download = TRUE,
quiet = FALSE)
nrow(osm_lines)
## get highway types of interest
ht <- c(
"motorway",
"motorway_link",
"primary",
"primary_link",
"secondary",
"tertiary",
"unclassified"
)
osm_major_roads <- osm_lines[osm_lines$highway %in% ht, ] %>%
sf::st_intersection(bb)
## plot data
plot(bb)
plot(
osm_major_roads["highway"]$geometry,
key.pos = 1,
add = T,
col = "red",
lwd = 0.7
)
}
# map Delft
map_city_streets2("Delft, Netherlands")
sl <- nrow(survey_google)
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets2(pull(survey_google[, 4])[sl])
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[, 4]
for (i in c(1,2,4,5,7:nrow(places))){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
#map places on interactive map
leaflet(bbx) %>% addProviderTiles("CartoDB.Positron") %>%
addPolygons()
survey_google[c(1,2,4,5,7:nrow(places)), 4]
# get places from csv survey
places <- survey_google[c(1,2,4,5,7:nrow(places)), 4]
places
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[c(1,2,4,5,7:nrow(places)), 4]
for (i in 1:nrow(places)){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
library(sf)
library(osmextract)
library(osmdata)
library(leaflet)
# get places from csv survey
places <- survey_google[c(1,2,4,5,7), 4]
for (i in 1:nrow(places)){
## get municipal boundary from osmdata
bb <- osmdata::getbb(
place_name = places[i,],
format_out = 'sf_polygon',
silent = FALSE
)
assign(paste0("bb", i), bb)
if(i == 1){
bbx <- bb
} else{
bbx <- rbind(bbx, bb)
}
}
#map places on interactive map
leaflet(bbx) %>% addProviderTiles("CartoDB.Positron") %>%
addPolygons()
sl <- nrow(survey_google)
# map_city_streets(survey_google[, 4][[sl-2:sl]])
map_city_streets(pull(survey_google[, 4])[4])
osmextract::oe_get("Vienna")
osmextract::oe_get("Vienna, Austria")
osmextract::oe_get("Vienna, Austria", force_download = TRUE)
lubrudate::mdy("June 1, 2015")
lubridate::mdy("June 1, 2015")
